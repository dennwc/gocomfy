// Code generated by comfy-classes. DO NOT EDIT.

package apinodes

type AUDIO Link
type CLIP Link
type CLIP_VISION Link
type CLIP_VISION_OUTPUT Link
type CONDITIONING Link
type CONTROL_NET Link
type GLIGEN Link
type GUIDER Link
type IMAGE Link
type LATENT Link
type MASK Link
type MODEL Link
type NOISE Link
type PHOTOMAKER Link
type SAMPLER Link
type SIGMAS Link
type STYLE_MODEL Link
type UPSCALE_MODEL Link
type VAE Link
type WEBCAM Link

func AddNoise(g *Graph, model MODEL, noise NOISE, sigmas SIGMAS, latent_image LATENT) (_ *Node, latent LATENT) {
	n := &Node{
		Class: "AddNoise",
		Inputs: map[string]Value{
			"model":        Link(model),
			"noise":        Link(noise),
			"sigmas":       Link(sigmas),
			"latent_image": Link(latent_image),
		},
	}
	id := g.Add(n)
	return n, LATENT{NodeID: id, OutPort: 0}
}

func AlignYourStepsScheduler(g *Graph, model_type string, steps int, denoise float64) (_ *Node, sigmas SIGMAS) {
	n := &Node{
		Class: "AlignYourStepsScheduler",
		Inputs: map[string]Value{
			"model_type": String(model_type),
			"steps":      Int(steps),
			"denoise":    Float(denoise),
		},
	}
	id := g.Add(n)
	return n, SIGMAS{NodeID: id, OutPort: 0}
}

func BasicGuider(g *Graph, model MODEL, conditioning CONDITIONING) (_ *Node, guider GUIDER) {
	n := &Node{
		Class: "BasicGuider",
		Inputs: map[string]Value{
			"model":        Link(model),
			"conditioning": Link(conditioning),
		},
	}
	id := g.Add(n)
	return n, GUIDER{NodeID: id, OutPort: 0}
}

func BasicScheduler(g *Graph, model MODEL, scheduler string, steps int, denoise float64) (_ *Node, sigmas SIGMAS) {
	n := &Node{
		Class: "BasicScheduler",
		Inputs: map[string]Value{
			"model":     Link(model),
			"scheduler": String(scheduler),
			"steps":     Int(steps),
			"denoise":   Float(denoise),
		},
	}
	id := g.Add(n)
	return n, SIGMAS{NodeID: id, OutPort: 0}
}

func CFGGuider(g *Graph, model MODEL, positive CONDITIONING, negative CONDITIONING, cfg float64) (_ *Node, guider GUIDER) {
	n := &Node{
		Class: "CFGGuider",
		Inputs: map[string]Value{
			"model":    Link(model),
			"positive": Link(positive),
			"negative": Link(negative),
			"cfg":      Float(cfg),
		},
	}
	id := g.Add(n)
	return n, GUIDER{NodeID: id, OutPort: 0}
}

func CLIPAttentionMultiply(g *Graph, clip CLIP, q, k, v, out float64) (_ *Node, out_clip CLIP) {
	n := &Node{
		Class: "CLIPAttentionMultiply",
		Inputs: map[string]Value{
			"clip": Link(clip),
			"q":    Float(q),
			"k":    Float(k),
			"v":    Float(v),
			"out":  Float(out),
		},
	}
	id := g.Add(n)
	return n, CLIP{NodeID: id, OutPort: 0}
}

// CLIPLoader - Load CLIP
func CLIPLoader(g *Graph, clip_name, typ string) (_ *Node, clip CLIP) {
	n := &Node{
		Class: "CLIPLoader",
		Inputs: map[string]Value{
			"clip_name": String(clip_name),
			"type":      String(typ),
		},
	}
	id := g.Add(n)
	return n, CLIP{NodeID: id, OutPort: 0}
}

func CLIPMergeAdd(g *Graph, clip1 CLIP, clip2 CLIP) (_ *Node, clip CLIP) {
	n := &Node{
		Class: "CLIPMergeAdd",
		Inputs: map[string]Value{
			"clip1": Link(clip1),
			"clip2": Link(clip2),
		},
	}
	id := g.Add(n)
	return n, CLIP{NodeID: id, OutPort: 0}
}

func CLIPMergeSimple(g *Graph, clip1 CLIP, clip2 CLIP, ratio float64) (_ *Node, clip CLIP) {
	n := &Node{
		Class: "CLIPMergeSimple",
		Inputs: map[string]Value{
			"clip1": Link(clip1),
			"clip2": Link(clip2),
			"ratio": Float(ratio),
		},
	}
	id := g.Add(n)
	return n, CLIP{NodeID: id, OutPort: 0}
}

func CLIPMergeSubtract(g *Graph, clip1 CLIP, clip2 CLIP, multiplier float64) (_ *Node, clip CLIP) {
	n := &Node{
		Class: "CLIPMergeSubtract",
		Inputs: map[string]Value{
			"clip1":      Link(clip1),
			"clip2":      Link(clip2),
			"multiplier": Float(multiplier),
		},
	}
	id := g.Add(n)
	return n, CLIP{NodeID: id, OutPort: 0}
}

func CLIPSave(g *Graph, clip CLIP, filename_prefix string) (_ *Node) {
	n := &Node{
		Class: "CLIPSave",
		Inputs: map[string]Value{
			"clip":            Link(clip),
			"filename_prefix": String(filename_prefix),
		},
	}
	g.Add(n)
	return n
}

// CLIPSetLastLayer - CLIP Set Last Layer
func CLIPSetLastLayer(g *Graph, clip CLIP, stop_at_clip_layer int) (_ *Node, out_clip CLIP) {
	n := &Node{
		Class: "CLIPSetLastLayer",
		Inputs: map[string]Value{
			"clip":               Link(clip),
			"stop_at_clip_layer": Int(stop_at_clip_layer),
		},
	}
	id := g.Add(n)
	return n, CLIP{NodeID: id, OutPort: 0}
}

// CLIPTextEncode - CLIP Text Encode (Prompt)
func CLIPTextEncode(g *Graph, clip CLIP, text string) (_ *Node, conditioning CONDITIONING) {
	n := &Node{
		Class: "CLIPTextEncode",
		Inputs: map[string]Value{
			"text": String(text),
			"clip": Link(clip),
		},
	}
	id := g.Add(n)
	return n, CONDITIONING{NodeID: id, OutPort: 0}
}

func CLIPTextEncodeControlnet(g *Graph, clip CLIP, conditioning CONDITIONING, text string) (_ *Node, out_conditioning CONDITIONING) {
	n := &Node{
		Class: "CLIPTextEncodeControlnet",
		Inputs: map[string]Value{
			"clip":         Link(clip),
			"conditioning": Link(conditioning),
			"text":         String(text),
		},
	}
	id := g.Add(n)
	return n, CONDITIONING{NodeID: id, OutPort: 0}
}

func CLIPTextEncodeSD3(g *Graph, clip CLIP, clip_l, clip_g, t5xxl, empty_padding string) (_ *Node, conditioning CONDITIONING) {
	n := &Node{
		Class: "CLIPTextEncodeSD3",
		Inputs: map[string]Value{
			"clip":          Link(clip),
			"clip_l":        String(clip_l),
			"clip_g":        String(clip_g),
			"t5xxl":         String(t5xxl),
			"empty_padding": String(empty_padding),
		},
	}
	id := g.Add(n)
	return n, CONDITIONING{NodeID: id, OutPort: 0}
}

func CLIPTextEncodeSDXL(g *Graph, clip CLIP, width, height, crop_w, crop_h, target_width, target_height int, text_g string, text_l string) (_ *Node, conditioning CONDITIONING) {
	n := &Node{
		Class: "CLIPTextEncodeSDXL",
		Inputs: map[string]Value{
			"width":         Int(width),
			"height":        Int(height),
			"crop_w":        Int(crop_w),
			"crop_h":        Int(crop_h),
			"target_width":  Int(target_width),
			"target_height": Int(target_height),
			"text_g":        String(text_g),
			"clip":          Link(clip),
			"text_l":        String(text_l),
		},
	}
	id := g.Add(n)
	return n, CONDITIONING{NodeID: id, OutPort: 0}
}

func CLIPTextEncodeSDXLRefiner(g *Graph, clip CLIP, ascore float64, width, height int, text string) (_ *Node, conditioning CONDITIONING) {
	n := &Node{
		Class: "CLIPTextEncodeSDXLRefiner",
		Inputs: map[string]Value{
			"ascore": Float(ascore),
			"width":  Int(width),
			"height": Int(height),
			"text":   String(text),
			"clip":   Link(clip),
		},
	}
	id := g.Add(n)
	return n, CONDITIONING{NodeID: id, OutPort: 0}
}

// CLIPVisionEncode - CLIP Vision Encode
func CLIPVisionEncode(g *Graph, clip_vision CLIP_VISION, image IMAGE) (_ *Node, clip_vision_output CLIP_VISION_OUTPUT) {
	n := &Node{
		Class: "CLIPVisionEncode",
		Inputs: map[string]Value{
			"clip_vision": Link(clip_vision),
			"image":       Link(image),
		},
	}
	id := g.Add(n)
	return n, CLIP_VISION_OUTPUT{NodeID: id, OutPort: 0}
}

// CLIPVisionLoader - Load CLIP Vision
func CLIPVisionLoader(g *Graph, clip_name string) (_ *Node, clip_vision CLIP_VISION) {
	n := &Node{
		Class: "CLIPVisionLoader",
		Inputs: map[string]Value{
			"clip_name": String(clip_name),
		},
	}
	id := g.Add(n)
	return n, CLIP_VISION{NodeID: id, OutPort: 0}
}

func Canny(g *Graph, image IMAGE, low_threshold, high_threshold float64) (_ *Node, out_image IMAGE) {
	n := &Node{
		Class: "Canny",
		Inputs: map[string]Value{
			"image":          Link(image),
			"low_threshold":  Float(low_threshold),
			"high_threshold": Float(high_threshold),
		},
	}
	id := g.Add(n)
	return n, IMAGE{NodeID: id, OutPort: 0}
}

// CheckpointLoader - Load Checkpoint With Config (DEPRECATED)
func CheckpointLoader(g *Graph, config_name, ckpt_name string) (_ *Node, model MODEL, clip CLIP, vae VAE) {
	n := &Node{
		Class: "CheckpointLoader",
		Inputs: map[string]Value{
			"config_name": String(config_name),
			"ckpt_name":   String(ckpt_name),
		},
	}
	id := g.Add(n)
	return n, MODEL{NodeID: id, OutPort: 0}, CLIP{NodeID: id, OutPort: 1}, VAE{NodeID: id, OutPort: 2}
}

// CheckpointLoaderSimple - Load Checkpoint
func CheckpointLoaderSimple(g *Graph, ckpt_name string) (_ *Node, model MODEL, clip CLIP, vae VAE) {
	n := &Node{
		Class: "CheckpointLoaderSimple",
		Inputs: map[string]Value{
			"ckpt_name": String(ckpt_name),
		},
	}
	id := g.Add(n)
	return n, MODEL{NodeID: id, OutPort: 0}, CLIP{NodeID: id, OutPort: 1}, VAE{NodeID: id, OutPort: 2}
}

func CheckpointSave(g *Graph, model MODEL, clip CLIP, vae VAE, filename_prefix string) (_ *Node) {
	n := &Node{
		Class: "CheckpointSave",
		Inputs: map[string]Value{
			"model":           Link(model),
			"clip":            Link(clip),
			"vae":             Link(vae),
			"filename_prefix": String(filename_prefix),
		},
	}
	g.Add(n)
	return n
}

func ConditioningAverage(g *Graph, conditioning_to CONDITIONING, conditioning_from CONDITIONING, conditioning_to_strength float64) (_ *Node, conditioning CONDITIONING) {
	n := &Node{
		Class: "ConditioningAverage",
		Inputs: map[string]Value{
			"conditioning_to":          Link(conditioning_to),
			"conditioning_from":        Link(conditioning_from),
			"conditioning_to_strength": Float(conditioning_to_strength),
		},
	}
	id := g.Add(n)
	return n, CONDITIONING{NodeID: id, OutPort: 0}
}

// ConditioningCombine - Conditioning (Combine)
func ConditioningCombine(g *Graph, conditioning_1 CONDITIONING, conditioning_2 CONDITIONING) (_ *Node, conditioning CONDITIONING) {
	n := &Node{
		Class: "ConditioningCombine",
		Inputs: map[string]Value{
			"conditioning_1": Link(conditioning_1),
			"conditioning_2": Link(conditioning_2),
		},
	}
	id := g.Add(n)
	return n, CONDITIONING{NodeID: id, OutPort: 0}
}

// ConditioningConcat - Conditioning (Concat)
func ConditioningConcat(g *Graph, conditioning_to CONDITIONING, conditioning_from CONDITIONING) (_ *Node, conditioning CONDITIONING) {
	n := &Node{
		Class: "ConditioningConcat",
		Inputs: map[string]Value{
			"conditioning_to":   Link(conditioning_to),
			"conditioning_from": Link(conditioning_from),
		},
	}
	id := g.Add(n)
	return n, CONDITIONING{NodeID: id, OutPort: 0}
}

// ConditioningSetArea - Conditioning (Set Area)
func ConditioningSetArea(g *Graph, conditioning CONDITIONING, width, height, x, y int, strength float64) (_ *Node, out_conditioning CONDITIONING) {
	n := &Node{
		Class: "ConditioningSetArea",
		Inputs: map[string]Value{
			"conditioning": Link(conditioning),
			"width":        Int(width),
			"height":       Int(height),
			"x":            Int(x),
			"y":            Int(y),
			"strength":     Float(strength),
		},
	}
	id := g.Add(n)
	return n, CONDITIONING{NodeID: id, OutPort: 0}
}

// ConditioningSetAreaPercentage - Conditioning (Set Area with Percentage)
func ConditioningSetAreaPercentage(g *Graph, conditioning CONDITIONING, width, height, x, y, strength float64) (_ *Node, out_conditioning CONDITIONING) {
	n := &Node{
		Class: "ConditioningSetAreaPercentage",
		Inputs: map[string]Value{
			"conditioning": Link(conditioning),
			"width":        Float(width),
			"height":       Float(height),
			"x":            Float(x),
			"y":            Float(y),
			"strength":     Float(strength),
		},
	}
	id := g.Add(n)
	return n, CONDITIONING{NodeID: id, OutPort: 0}
}

func ConditioningSetAreaStrength(g *Graph, conditioning CONDITIONING, strength float64) (_ *Node, out_conditioning CONDITIONING) {
	n := &Node{
		Class: "ConditioningSetAreaStrength",
		Inputs: map[string]Value{
			"conditioning": Link(conditioning),
			"strength":     Float(strength),
		},
	}
	id := g.Add(n)
	return n, CONDITIONING{NodeID: id, OutPort: 0}
}

// ConditioningSetMask - Conditioning (Set Mask)
func ConditioningSetMask(g *Graph, conditioning CONDITIONING, mask MASK, strength float64, set_cond_area string) (_ *Node, out_conditioning CONDITIONING) {
	n := &Node{
		Class: "ConditioningSetMask",
		Inputs: map[string]Value{
			"conditioning":  Link(conditioning),
			"mask":          Link(mask),
			"strength":      Float(strength),
			"set_cond_area": String(set_cond_area),
		},
	}
	id := g.Add(n)
	return n, CONDITIONING{NodeID: id, OutPort: 0}
}

func ConditioningSetTimestepRange(g *Graph, conditioning CONDITIONING, start, end float64) (_ *Node, out_conditioning CONDITIONING) {
	n := &Node{
		Class: "ConditioningSetTimestepRange",
		Inputs: map[string]Value{
			"conditioning": Link(conditioning),
			"start":        Float(start),
			"end":          Float(end),
		},
	}
	id := g.Add(n)
	return n, CONDITIONING{NodeID: id, OutPort: 0}
}

func ConditioningZeroOut(g *Graph, conditioning CONDITIONING) (_ *Node, out_conditioning CONDITIONING) {
	n := &Node{
		Class: "ConditioningZeroOut",
		Inputs: map[string]Value{
			"conditioning": Link(conditioning),
		},
	}
	id := g.Add(n)
	return n, CONDITIONING{NodeID: id, OutPort: 0}
}

// ControlNetApply - Apply ControlNet
func ControlNetApply(g *Graph, conditioning CONDITIONING, control_net CONTROL_NET, image IMAGE, strength float64) (_ *Node, out_conditioning CONDITIONING) {
	n := &Node{
		Class: "ControlNetApply",
		Inputs: map[string]Value{
			"conditioning": Link(conditioning),
			"control_net":  Link(control_net),
			"image":        Link(image),
			"strength":     Float(strength),
		},
	}
	id := g.Add(n)
	return n, CONDITIONING{NodeID: id, OutPort: 0}
}

// ControlNetApplyAdvanced - Apply ControlNet (Advanced)
func ControlNetApplyAdvanced(g *Graph, positive CONDITIONING, negative CONDITIONING, control_net CONTROL_NET, image IMAGE, strength, start_percent, end_percent float64) (_ *Node, out_positive CONDITIONING, out_negative CONDITIONING) {
	n := &Node{
		Class: "ControlNetApplyAdvanced",
		Inputs: map[string]Value{
			"positive":      Link(positive),
			"negative":      Link(negative),
			"control_net":   Link(control_net),
			"image":         Link(image),
			"strength":      Float(strength),
			"start_percent": Float(start_percent),
			"end_percent":   Float(end_percent),
		},
	}
	id := g.Add(n)
	return n, CONDITIONING{NodeID: id, OutPort: 0}, CONDITIONING{NodeID: id, OutPort: 1}
}

// ControlNetLoader - Load ControlNet Model
func ControlNetLoader(g *Graph, control_net_name string) (_ *Node, control_net CONTROL_NET) {
	n := &Node{
		Class: "ControlNetLoader",
		Inputs: map[string]Value{
			"control_net_name": String(control_net_name),
		},
	}
	id := g.Add(n)
	return n, CONTROL_NET{NodeID: id, OutPort: 0}
}

func CropMask(g *Graph, mask MASK, x, y, width, height int) (_ *Node, out_mask MASK) {
	n := &Node{
		Class: "CropMask",
		Inputs: map[string]Value{
			"mask":   Link(mask),
			"x":      Int(x),
			"y":      Int(y),
			"width":  Int(width),
			"height": Int(height),
		},
	}
	id := g.Add(n)
	return n, MASK{NodeID: id, OutPort: 0}
}

// DiffControlNetLoader - Load ControlNet Model (diff)
func DiffControlNetLoader(g *Graph, model MODEL, control_net_name string) (_ *Node, control_net CONTROL_NET) {
	n := &Node{
		Class: "DiffControlNetLoader",
		Inputs: map[string]Value{
			"model":            Link(model),
			"control_net_name": String(control_net_name),
		},
	}
	id := g.Add(n)
	return n, CONTROL_NET{NodeID: id, OutPort: 0}
}

// DifferentialDiffusion - Differential Diffusion
func DifferentialDiffusion(g *Graph, model MODEL) (_ *Node, out_model MODEL) {
	n := &Node{
		Class: "DifferentialDiffusion",
		Inputs: map[string]Value{
			"model": Link(model),
		},
	}
	id := g.Add(n)
	return n, MODEL{NodeID: id, OutPort: 0}
}

func DiffusersLoader(g *Graph, model_path string) (_ *Node, model MODEL, clip CLIP, vae VAE) {
	n := &Node{
		Class: "DiffusersLoader",
		Inputs: map[string]Value{
			"model_path": String(model_path),
		},
	}
	id := g.Add(n)
	return n, MODEL{NodeID: id, OutPort: 0}, CLIP{NodeID: id, OutPort: 1}, VAE{NodeID: id, OutPort: 2}
}

func DisableNoise(g *Graph) (_ *Node, noise NOISE) {
	n := &Node{
		Class:  "DisableNoise",
		Inputs: map[string]Value{},
	}
	id := g.Add(n)
	return n, NOISE{NodeID: id, OutPort: 0}
}

func DualCFGGuider(g *Graph, model MODEL, cond1 CONDITIONING, cond2 CONDITIONING, negative CONDITIONING, cfg_conds, cfg_cond2_negative float64) (_ *Node, guider GUIDER) {
	n := &Node{
		Class: "DualCFGGuider",
		Inputs: map[string]Value{
			"model":              Link(model),
			"cond1":              Link(cond1),
			"cond2":              Link(cond2),
			"negative":           Link(negative),
			"cfg_conds":          Float(cfg_conds),
			"cfg_cond2_negative": Float(cfg_cond2_negative),
		},
	}
	id := g.Add(n)
	return n, GUIDER{NodeID: id, OutPort: 0}
}

func DualCLIPLoader(g *Graph, clip_name1, clip_name2, typ string) (_ *Node, clip CLIP) {
	n := &Node{
		Class: "DualCLIPLoader",
		Inputs: map[string]Value{
			"clip_name1": String(clip_name1),
			"clip_name2": String(clip_name2),
			"type":       String(typ),
		},
	}
	id := g.Add(n)
	return n, CLIP{NodeID: id, OutPort: 0}
}

func EmptyImage(g *Graph, width, height, batch_size, color int) (_ *Node, image IMAGE) {
	n := &Node{
		Class: "EmptyImage",
		Inputs: map[string]Value{
			"width":      Int(width),
			"height":     Int(height),
			"batch_size": Int(batch_size),
			"color":      Int(color),
		},
	}
	id := g.Add(n)
	return n, IMAGE{NodeID: id, OutPort: 0}
}

func EmptyLatentAudio(g *Graph) (_ *Node, latent LATENT) {
	n := &Node{
		Class:  "EmptyLatentAudio",
		Inputs: map[string]Value{},
	}
	id := g.Add(n)
	return n, LATENT{NodeID: id, OutPort: 0}
}

// EmptyLatentImage - Empty Latent Image
func EmptyLatentImage(g *Graph, width, height, batch_size int) (_ *Node, latent LATENT) {
	n := &Node{
		Class: "EmptyLatentImage",
		Inputs: map[string]Value{
			"width":      Int(width),
			"height":     Int(height),
			"batch_size": Int(batch_size),
		},
	}
	id := g.Add(n)
	return n, LATENT{NodeID: id, OutPort: 0}
}

func EmptySD3LatentImage(g *Graph, width, height, batch_size int) (_ *Node, latent LATENT) {
	n := &Node{
		Class: "EmptySD3LatentImage",
		Inputs: map[string]Value{
			"width":      Int(width),
			"height":     Int(height),
			"batch_size": Int(batch_size),
		},
	}
	id := g.Add(n)
	return n, LATENT{NodeID: id, OutPort: 0}
}

func ExponentialScheduler(g *Graph, steps int, sigma_max, sigma_min float64) (_ *Node, sigmas SIGMAS) {
	n := &Node{
		Class: "ExponentialScheduler",
		Inputs: map[string]Value{
			"steps":     Int(steps),
			"sigma_max": Float(sigma_max),
			"sigma_min": Float(sigma_min),
		},
	}
	id := g.Add(n)
	return n, SIGMAS{NodeID: id, OutPort: 0}
}

func FeatherMask(g *Graph, mask MASK, left, top, right, bottom int) (_ *Node, out_mask MASK) {
	n := &Node{
		Class: "FeatherMask",
		Inputs: map[string]Value{
			"mask":   Link(mask),
			"left":   Int(left),
			"top":    Int(top),
			"right":  Int(right),
			"bottom": Int(bottom),
		},
	}
	id := g.Add(n)
	return n, MASK{NodeID: id, OutPort: 0}
}

func FlipSigmas(g *Graph, sigmas SIGMAS) (_ *Node, out_sigmas SIGMAS) {
	n := &Node{
		Class: "FlipSigmas",
		Inputs: map[string]Value{
			"sigmas": Link(sigmas),
		},
	}
	id := g.Add(n)
	return n, SIGMAS{NodeID: id, OutPort: 0}
}

func FreeU(g *Graph, model MODEL, b1, b2, s1, s2 float64) (_ *Node, out_model MODEL) {
	n := &Node{
		Class: "FreeU",
		Inputs: map[string]Value{
			"model": Link(model),
			"b1":    Float(b1),
			"b2":    Float(b2),
			"s1":    Float(s1),
			"s2":    Float(s2),
		},
	}
	id := g.Add(n)
	return n, MODEL{NodeID: id, OutPort: 0}
}

func FreeU_V2(g *Graph, model MODEL, b1, b2, s1, s2 float64) (_ *Node, out_model MODEL) {
	n := &Node{
		Class: "FreeU_V2",
		Inputs: map[string]Value{
			"model": Link(model),
			"b1":    Float(b1),
			"b2":    Float(b2),
			"s1":    Float(s1),
			"s2":    Float(s2),
		},
	}
	id := g.Add(n)
	return n, MODEL{NodeID: id, OutPort: 0}
}

func GITSScheduler(g *Graph, coeff float64, steps int, denoise float64) (_ *Node, sigmas SIGMAS) {
	n := &Node{
		Class: "GITSScheduler",
		Inputs: map[string]Value{
			"coeff":   Float(coeff),
			"steps":   Int(steps),
			"denoise": Float(denoise),
		},
	}
	id := g.Add(n)
	return n, SIGMAS{NodeID: id, OutPort: 0}
}

func GLIGENLoader(g *Graph, gligen_name string) (_ *Node, gligen GLIGEN) {
	n := &Node{
		Class: "GLIGENLoader",
		Inputs: map[string]Value{
			"gligen_name": String(gligen_name),
		},
	}
	id := g.Add(n)
	return n, GLIGEN{NodeID: id, OutPort: 0}
}

func GLIGENTextBoxApply(g *Graph, conditioning_to CONDITIONING, clip CLIP, gligen_textbox_model GLIGEN, text string, width, height, x, y int) (_ *Node, conditioning CONDITIONING) {
	n := &Node{
		Class: "GLIGENTextBoxApply",
		Inputs: map[string]Value{
			"conditioning_to":      Link(conditioning_to),
			"clip":                 Link(clip),
			"gligen_textbox_model": Link(gligen_textbox_model),
			"text":                 String(text),
			"width":                Int(width),
			"height":               Int(height),
			"x":                    Int(x),
			"y":                    Int(y),
		},
	}
	id := g.Add(n)
	return n, CONDITIONING{NodeID: id, OutPort: 0}
}

func GrowMask(g *Graph, mask MASK, expand int, tapered_corners bool) (_ *Node, out_mask MASK) {
	n := &Node{
		Class: "GrowMask",
		Inputs: map[string]Value{
			"mask":            Link(mask),
			"expand":          Int(expand),
			"tapered_corners": Bool(tapered_corners),
		},
	}
	id := g.Add(n)
	return n, MASK{NodeID: id, OutPort: 0}
}

func HyperTile(g *Graph, model MODEL, tile_size, swap_size, max_depth int, scale_depth bool) (_ *Node, out_model MODEL) {
	n := &Node{
		Class: "HyperTile",
		Inputs: map[string]Value{
			"model":       Link(model),
			"tile_size":   Int(tile_size),
			"swap_size":   Int(swap_size),
			"max_depth":   Int(max_depth),
			"scale_depth": Bool(scale_depth),
		},
	}
	id := g.Add(n)
	return n, MODEL{NodeID: id, OutPort: 0}
}

func HypernetworkLoader(g *Graph, model MODEL, hypernetwork_name string, strength float64) (_ *Node, out_model MODEL) {
	n := &Node{
		Class: "HypernetworkLoader",
		Inputs: map[string]Value{
			"model":             Link(model),
			"hypernetwork_name": String(hypernetwork_name),
			"strength":          Float(strength),
		},
	}
	id := g.Add(n)
	return n, MODEL{NodeID: id, OutPort: 0}
}

// ImageBatch - Batch Images
func ImageBatch(g *Graph, image1 IMAGE, image2 IMAGE) (_ *Node, image IMAGE) {
	n := &Node{
		Class: "ImageBatch",
		Inputs: map[string]Value{
			"image1": Link(image1),
			"image2": Link(image2),
		},
	}
	id := g.Add(n)
	return n, IMAGE{NodeID: id, OutPort: 0}
}

func ImageBlend(g *Graph, image1 IMAGE, image2 IMAGE, blend_factor float64, blend_mode string) (_ *Node, image IMAGE) {
	n := &Node{
		Class: "ImageBlend",
		Inputs: map[string]Value{
			"image1":       Link(image1),
			"image2":       Link(image2),
			"blend_factor": Float(blend_factor),
			"blend_mode":   String(blend_mode),
		},
	}
	id := g.Add(n)
	return n, IMAGE{NodeID: id, OutPort: 0}
}

func ImageBlur(g *Graph, image IMAGE, blur_radius int, sigma float64) (_ *Node, out_image IMAGE) {
	n := &Node{
		Class: "ImageBlur",
		Inputs: map[string]Value{
			"image":       Link(image),
			"blur_radius": Int(blur_radius),
			"sigma":       Float(sigma),
		},
	}
	id := g.Add(n)
	return n, IMAGE{NodeID: id, OutPort: 0}
}

func ImageColorToMask(g *Graph, image IMAGE, color int) (_ *Node, mask MASK) {
	n := &Node{
		Class: "ImageColorToMask",
		Inputs: map[string]Value{
			"image": Link(image),
			"color": Int(color),
		},
	}
	id := g.Add(n)
	return n, MASK{NodeID: id, OutPort: 0}
}

func ImageCompositeMasked(g *Graph, destination IMAGE, source IMAGE, mask MASK, x, y int, resize_source bool) (_ *Node, image IMAGE) {
	n := &Node{
		Class: "ImageCompositeMasked",
		Inputs: map[string]Value{
			"destination":   Link(destination),
			"source":        Link(source),
			"x":             Int(x),
			"y":             Int(y),
			"resize_source": Bool(resize_source),
		},
	}
	id := g.Add(n)
	return n, IMAGE{NodeID: id, OutPort: 0}
}

func ImageCrop(g *Graph, image IMAGE, width, height, x, y int) (_ *Node, out_image IMAGE) {
	n := &Node{
		Class: "ImageCrop",
		Inputs: map[string]Value{
			"image":  Link(image),
			"width":  Int(width),
			"height": Int(height),
			"x":      Int(x),
			"y":      Int(y),
		},
	}
	id := g.Add(n)
	return n, IMAGE{NodeID: id, OutPort: 0}
}

func ImageFromBatch(g *Graph, image IMAGE, batch_index, length int) (_ *Node, out_image IMAGE) {
	n := &Node{
		Class: "ImageFromBatch",
		Inputs: map[string]Value{
			"image":       Link(image),
			"batch_index": Int(batch_index),
			"length":      Int(length),
		},
	}
	id := g.Add(n)
	return n, IMAGE{NodeID: id, OutPort: 0}
}

// ImageInvert - Invert Image
func ImageInvert(g *Graph, image IMAGE) (_ *Node, out_image IMAGE) {
	n := &Node{
		Class: "ImageInvert",
		Inputs: map[string]Value{
			"image": Link(image),
		},
	}
	id := g.Add(n)
	return n, IMAGE{NodeID: id, OutPort: 0}
}

// ImageOnlyCheckpointLoader - Image Only Checkpoint Loader (img2vid model)
func ImageOnlyCheckpointLoader(g *Graph, ckpt_name string) (_ *Node, model MODEL, clip_vision CLIP_VISION, vae VAE) {
	n := &Node{
		Class: "ImageOnlyCheckpointLoader",
		Inputs: map[string]Value{
			"ckpt_name": String(ckpt_name),
		},
	}
	id := g.Add(n)
	return n, MODEL{NodeID: id, OutPort: 0}, CLIP_VISION{NodeID: id, OutPort: 1}, VAE{NodeID: id, OutPort: 2}
}

func ImageOnlyCheckpointSave(g *Graph, model MODEL, clip_vision CLIP_VISION, vae VAE, filename_prefix string) (_ *Node) {
	n := &Node{
		Class: "ImageOnlyCheckpointSave",
		Inputs: map[string]Value{
			"model":           Link(model),
			"clip_vision":     Link(clip_vision),
			"vae":             Link(vae),
			"filename_prefix": String(filename_prefix),
		},
	}
	g.Add(n)
	return n
}

// ImagePadForOutpaint - Pad Image for Outpainting
func ImagePadForOutpaint(g *Graph, image IMAGE, left, top, right, bottom, feathering int) (_ *Node, out_image IMAGE, mask MASK) {
	n := &Node{
		Class: "ImagePadForOutpaint",
		Inputs: map[string]Value{
			"image":      Link(image),
			"left":       Int(left),
			"top":        Int(top),
			"right":      Int(right),
			"bottom":     Int(bottom),
			"feathering": Int(feathering),
		},
	}
	id := g.Add(n)
	return n, IMAGE{NodeID: id, OutPort: 0}, MASK{NodeID: id, OutPort: 1}
}

func ImageQuantize(g *Graph, image IMAGE, colors int, dither string) (_ *Node, out_image IMAGE) {
	n := &Node{
		Class: "ImageQuantize",
		Inputs: map[string]Value{
			"image":  Link(image),
			"colors": Int(colors),
			"dither": String(dither),
		},
	}
	id := g.Add(n)
	return n, IMAGE{NodeID: id, OutPort: 0}
}

// ImageScale - Upscale Image
func ImageScale(g *Graph, image IMAGE, upscale_method string, width, height int, crop string) (_ *Node, out_image IMAGE) {
	n := &Node{
		Class: "ImageScale",
		Inputs: map[string]Value{
			"image":          Link(image),
			"upscale_method": String(upscale_method),
			"width":          Int(width),
			"height":         Int(height),
			"crop":           String(crop),
		},
	}
	id := g.Add(n)
	return n, IMAGE{NodeID: id, OutPort: 0}
}

// ImageScaleBy - Upscale Image By
func ImageScaleBy(g *Graph, image IMAGE, upscale_method string, scale_by float64) (_ *Node, out_image IMAGE) {
	n := &Node{
		Class: "ImageScaleBy",
		Inputs: map[string]Value{
			"image":          Link(image),
			"upscale_method": String(upscale_method),
			"scale_by":       Float(scale_by),
		},
	}
	id := g.Add(n)
	return n, IMAGE{NodeID: id, OutPort: 0}
}

func ImageScaleToTotalPixels(g *Graph, image IMAGE, upscale_method string, megapixels float64) (_ *Node, out_image IMAGE) {
	n := &Node{
		Class: "ImageScaleToTotalPixels",
		Inputs: map[string]Value{
			"image":          Link(image),
			"upscale_method": String(upscale_method),
			"megapixels":     Float(megapixels),
		},
	}
	id := g.Add(n)
	return n, IMAGE{NodeID: id, OutPort: 0}
}

func ImageSharpen(g *Graph, image IMAGE, sharpen_radius int, sigma, alpha float64) (_ *Node, out_image IMAGE) {
	n := &Node{
		Class: "ImageSharpen",
		Inputs: map[string]Value{
			"image":          Link(image),
			"sharpen_radius": Int(sharpen_radius),
			"sigma":          Float(sigma),
			"alpha":          Float(alpha),
		},
	}
	id := g.Add(n)
	return n, IMAGE{NodeID: id, OutPort: 0}
}

// ImageToMask - Convert Image to Mask
func ImageToMask(g *Graph, image IMAGE, channel string) (_ *Node, mask MASK) {
	n := &Node{
		Class: "ImageToMask",
		Inputs: map[string]Value{
			"image":   Link(image),
			"channel": String(channel),
		},
	}
	id := g.Add(n)
	return n, MASK{NodeID: id, OutPort: 0}
}

// ImageUpscaleWithModel - Upscale Image (using Model)
func ImageUpscaleWithModel(g *Graph, upscale_model UPSCALE_MODEL, image IMAGE) (_ *Node, out_image IMAGE) {
	n := &Node{
		Class: "ImageUpscaleWithModel",
		Inputs: map[string]Value{
			"upscale_model": Link(upscale_model),
			"image":         Link(image),
		},
	}
	id := g.Add(n)
	return n, IMAGE{NodeID: id, OutPort: 0}
}

func InpaintModelConditioning(g *Graph, positive CONDITIONING, negative CONDITIONING, vae VAE, pixels IMAGE, mask MASK) (_ *Node, out_positive CONDITIONING, out_negative CONDITIONING, latent LATENT) {
	n := &Node{
		Class: "InpaintModelConditioning",
		Inputs: map[string]Value{
			"positive": Link(positive),
			"negative": Link(negative),
			"vae":      Link(vae),
			"pixels":   Link(pixels),
			"mask":     Link(mask),
		},
	}
	id := g.Add(n)
	return n, CONDITIONING{NodeID: id, OutPort: 0}, CONDITIONING{NodeID: id, OutPort: 1}, LATENT{NodeID: id, OutPort: 2}
}

func InstructPixToPixConditioning(g *Graph, positive CONDITIONING, negative CONDITIONING, vae VAE, pixels IMAGE) (_ *Node, out_positive CONDITIONING, out_negative CONDITIONING, latent LATENT) {
	n := &Node{
		Class: "InstructPixToPixConditioning",
		Inputs: map[string]Value{
			"positive": Link(positive),
			"negative": Link(negative),
			"vae":      Link(vae),
			"pixels":   Link(pixels),
		},
	}
	id := g.Add(n)
	return n, CONDITIONING{NodeID: id, OutPort: 0}, CONDITIONING{NodeID: id, OutPort: 1}, LATENT{NodeID: id, OutPort: 2}
}

func InvertMask(g *Graph, mask MASK) (_ *Node, out_mask MASK) {
	n := &Node{
		Class: "InvertMask",
		Inputs: map[string]Value{
			"mask": Link(mask),
		},
	}
	id := g.Add(n)
	return n, MASK{NodeID: id, OutPort: 0}
}

// JoinImageWithAlpha - Join Image with Alpha
func JoinImageWithAlpha(g *Graph, image IMAGE, alpha MASK) (_ *Node, out_image IMAGE) {
	n := &Node{
		Class: "JoinImageWithAlpha",
		Inputs: map[string]Value{
			"image": Link(image),
			"alpha": Link(alpha),
		},
	}
	id := g.Add(n)
	return n, IMAGE{NodeID: id, OutPort: 0}
}

func KSampler(g *Graph, model MODEL, positive CONDITIONING, negative CONDITIONING, latent_image LATENT, seed, steps int, cfg float64, sampler_name, scheduler string, denoise float64) (_ *Node, latent LATENT) {
	n := &Node{
		Class: "KSampler",
		Inputs: map[string]Value{
			"model":        Link(model),
			"seed":         Int(seed),
			"steps":        Int(steps),
			"cfg":          Float(cfg),
			"sampler_name": String(sampler_name),
			"scheduler":    String(scheduler),
			"positive":     Link(positive),
			"negative":     Link(negative),
			"latent_image": Link(latent_image),
			"denoise":      Float(denoise),
		},
	}
	id := g.Add(n)
	return n, LATENT{NodeID: id, OutPort: 0}
}

// KSamplerAdvanced - KSampler (Advanced)
func KSamplerAdvanced(g *Graph, model MODEL, positive CONDITIONING, negative CONDITIONING, latent_image LATENT, add_noise string, noise_seed, steps int, cfg float64, sampler_name, scheduler string, start_at_step, end_at_step int, return_with_leftover_noise string) (_ *Node, latent LATENT) {
	n := &Node{
		Class: "KSamplerAdvanced",
		Inputs: map[string]Value{
			"model":                      Link(model),
			"add_noise":                  String(add_noise),
			"noise_seed":                 Int(noise_seed),
			"steps":                      Int(steps),
			"cfg":                        Float(cfg),
			"sampler_name":               String(sampler_name),
			"scheduler":                  String(scheduler),
			"positive":                   Link(positive),
			"negative":                   Link(negative),
			"latent_image":               Link(latent_image),
			"start_at_step":              Int(start_at_step),
			"end_at_step":                Int(end_at_step),
			"return_with_leftover_noise": String(return_with_leftover_noise),
		},
	}
	id := g.Add(n)
	return n, LATENT{NodeID: id, OutPort: 0}
}

func KSamplerSelect(g *Graph, sampler_name string) (_ *Node, sampler SAMPLER) {
	n := &Node{
		Class: "KSamplerSelect",
		Inputs: map[string]Value{
			"sampler_name": String(sampler_name),
		},
	}
	id := g.Add(n)
	return n, SAMPLER{NodeID: id, OutPort: 0}
}

func KarrasScheduler(g *Graph, steps int, sigma_max, sigma_min, rho float64) (_ *Node, sigmas SIGMAS) {
	n := &Node{
		Class: "KarrasScheduler",
		Inputs: map[string]Value{
			"steps":     Int(steps),
			"sigma_max": Float(sigma_max),
			"sigma_min": Float(sigma_min),
			"rho":       Float(rho),
		},
	}
	id := g.Add(n)
	return n, SIGMAS{NodeID: id, OutPort: 0}
}

func LatentAdd(g *Graph, samples1 LATENT, samples2 LATENT) (_ *Node, latent LATENT) {
	n := &Node{
		Class: "LatentAdd",
		Inputs: map[string]Value{
			"samples1": Link(samples1),
			"samples2": Link(samples2),
		},
	}
	id := g.Add(n)
	return n, LATENT{NodeID: id, OutPort: 0}
}

func LatentBatch(g *Graph, samples1 LATENT, samples2 LATENT) (_ *Node, latent LATENT) {
	n := &Node{
		Class: "LatentBatch",
		Inputs: map[string]Value{
			"samples1": Link(samples1),
			"samples2": Link(samples2),
		},
	}
	id := g.Add(n)
	return n, LATENT{NodeID: id, OutPort: 0}
}

func LatentBatchSeedBehavior(g *Graph, samples LATENT, seed_behavior string) (_ *Node, latent LATENT) {
	n := &Node{
		Class: "LatentBatchSeedBehavior",
		Inputs: map[string]Value{
			"samples":       Link(samples),
			"seed_behavior": String(seed_behavior),
		},
	}
	id := g.Add(n)
	return n, LATENT{NodeID: id, OutPort: 0}
}

// LatentBlend - Latent Blend
func LatentBlend(g *Graph, samples1 LATENT, samples2 LATENT, blend_factor float64) (_ *Node, latent LATENT) {
	n := &Node{
		Class: "LatentBlend",
		Inputs: map[string]Value{
			"samples1":     Link(samples1),
			"samples2":     Link(samples2),
			"blend_factor": Float(blend_factor),
		},
	}
	id := g.Add(n)
	return n, LATENT{NodeID: id, OutPort: 0}
}

// LatentComposite - Latent Composite
func LatentComposite(g *Graph, samples_to LATENT, samples_from LATENT, x, y, feather int) (_ *Node, latent LATENT) {
	n := &Node{
		Class: "LatentComposite",
		Inputs: map[string]Value{
			"samples_to":   Link(samples_to),
			"samples_from": Link(samples_from),
			"x":            Int(x),
			"y":            Int(y),
			"feather":      Int(feather),
		},
	}
	id := g.Add(n)
	return n, LATENT{NodeID: id, OutPort: 0}
}

func LatentCompositeMasked(g *Graph, destination LATENT, source LATENT, mask MASK, x, y int, resize_source bool) (_ *Node, latent LATENT) {
	n := &Node{
		Class: "LatentCompositeMasked",
		Inputs: map[string]Value{
			"destination":   Link(destination),
			"source":        Link(source),
			"x":             Int(x),
			"y":             Int(y),
			"resize_source": Bool(resize_source),
		},
	}
	id := g.Add(n)
	return n, LATENT{NodeID: id, OutPort: 0}
}

// LatentCrop - Crop Latent
func LatentCrop(g *Graph, samples LATENT, width, height, x, y int) (_ *Node, latent LATENT) {
	n := &Node{
		Class: "LatentCrop",
		Inputs: map[string]Value{
			"samples": Link(samples),
			"width":   Int(width),
			"height":  Int(height),
			"x":       Int(x),
			"y":       Int(y),
		},
	}
	id := g.Add(n)
	return n, LATENT{NodeID: id, OutPort: 0}
}

// LatentFlip - Flip Latent
func LatentFlip(g *Graph, samples LATENT, flip_method string) (_ *Node, latent LATENT) {
	n := &Node{
		Class: "LatentFlip",
		Inputs: map[string]Value{
			"samples":     Link(samples),
			"flip_method": String(flip_method),
		},
	}
	id := g.Add(n)
	return n, LATENT{NodeID: id, OutPort: 0}
}

// LatentFromBatch - Latent From Batch
func LatentFromBatch(g *Graph, samples LATENT, batch_index, length int) (_ *Node, latent LATENT) {
	n := &Node{
		Class: "LatentFromBatch",
		Inputs: map[string]Value{
			"samples":     Link(samples),
			"batch_index": Int(batch_index),
			"length":      Int(length),
		},
	}
	id := g.Add(n)
	return n, LATENT{NodeID: id, OutPort: 0}
}

func LatentInterpolate(g *Graph, samples1 LATENT, samples2 LATENT, ratio float64) (_ *Node, latent LATENT) {
	n := &Node{
		Class: "LatentInterpolate",
		Inputs: map[string]Value{
			"samples1": Link(samples1),
			"samples2": Link(samples2),
			"ratio":    Float(ratio),
		},
	}
	id := g.Add(n)
	return n, LATENT{NodeID: id, OutPort: 0}
}

func LatentMultiply(g *Graph, samples LATENT, multiplier float64) (_ *Node, latent LATENT) {
	n := &Node{
		Class: "LatentMultiply",
		Inputs: map[string]Value{
			"samples":    Link(samples),
			"multiplier": Float(multiplier),
		},
	}
	id := g.Add(n)
	return n, LATENT{NodeID: id, OutPort: 0}
}

// LatentRotate - Rotate Latent
func LatentRotate(g *Graph, samples LATENT, rotation string) (_ *Node, latent LATENT) {
	n := &Node{
		Class: "LatentRotate",
		Inputs: map[string]Value{
			"samples":  Link(samples),
			"rotation": String(rotation),
		},
	}
	id := g.Add(n)
	return n, LATENT{NodeID: id, OutPort: 0}
}

func LatentSubtract(g *Graph, samples1 LATENT, samples2 LATENT) (_ *Node, latent LATENT) {
	n := &Node{
		Class: "LatentSubtract",
		Inputs: map[string]Value{
			"samples1": Link(samples1),
			"samples2": Link(samples2),
		},
	}
	id := g.Add(n)
	return n, LATENT{NodeID: id, OutPort: 0}
}

// LatentUpscale - Upscale Latent
func LatentUpscale(g *Graph, samples LATENT, upscale_method string, width, height int, crop string) (_ *Node, latent LATENT) {
	n := &Node{
		Class: "LatentUpscale",
		Inputs: map[string]Value{
			"samples":        Link(samples),
			"upscale_method": String(upscale_method),
			"width":          Int(width),
			"height":         Int(height),
			"crop":           String(crop),
		},
	}
	id := g.Add(n)
	return n, LATENT{NodeID: id, OutPort: 0}
}

// LatentUpscaleBy - Upscale Latent By
func LatentUpscaleBy(g *Graph, samples LATENT, upscale_method string, scale_by float64) (_ *Node, latent LATENT) {
	n := &Node{
		Class: "LatentUpscaleBy",
		Inputs: map[string]Value{
			"samples":        Link(samples),
			"upscale_method": String(upscale_method),
			"scale_by":       Float(scale_by),
		},
	}
	id := g.Add(n)
	return n, LATENT{NodeID: id, OutPort: 0}
}

func LoadAudio(g *Graph, audio string) (_ *Node, out_audio AUDIO) {
	n := &Node{
		Class: "LoadAudio",
		Inputs: map[string]Value{
			"audio": String(audio),
		},
	}
	id := g.Add(n)
	return n, AUDIO{NodeID: id, OutPort: 0}
}

// LoadImage - Load Image
func LoadImage(g *Graph, image string) (_ *Node, out_image IMAGE, mask MASK) {
	n := &Node{
		Class: "LoadImage",
		Inputs: map[string]Value{
			"image": String(image),
		},
	}
	id := g.Add(n)
	return n, IMAGE{NodeID: id, OutPort: 0}, MASK{NodeID: id, OutPort: 1}
}

// LoadImageMask - Load Image (as Mask)
func LoadImageMask(g *Graph, image, channel string) (_ *Node, mask MASK) {
	n := &Node{
		Class: "LoadImageMask",
		Inputs: map[string]Value{
			"image":   String(image),
			"channel": String(channel),
		},
	}
	id := g.Add(n)
	return n, MASK{NodeID: id, OutPort: 0}
}

func LoadLatent(g *Graph, latent string) (_ *Node, out_latent LATENT) {
	n := &Node{
		Class: "LoadLatent",
		Inputs: map[string]Value{
			"latent": String(latent),
		},
	}
	id := g.Add(n)
	return n, LATENT{NodeID: id, OutPort: 0}
}

// LoraLoader - Load LoRA
func LoraLoader(g *Graph, model MODEL, clip CLIP, lora_name string, strength_model, strength_clip float64) (_ *Node, out_model MODEL, out_clip CLIP) {
	n := &Node{
		Class: "LoraLoader",
		Inputs: map[string]Value{
			"model":          Link(model),
			"clip":           Link(clip),
			"lora_name":      String(lora_name),
			"strength_model": Float(strength_model),
			"strength_clip":  Float(strength_clip),
		},
	}
	id := g.Add(n)
	return n, MODEL{NodeID: id, OutPort: 0}, CLIP{NodeID: id, OutPort: 1}
}

func LoraLoaderModelOnly(g *Graph, model MODEL, lora_name string, strength_model float64) (_ *Node, out_model MODEL) {
	n := &Node{
		Class: "LoraLoaderModelOnly",
		Inputs: map[string]Value{
			"model":          Link(model),
			"lora_name":      String(lora_name),
			"strength_model": Float(strength_model),
		},
	}
	id := g.Add(n)
	return n, MODEL{NodeID: id, OutPort: 0}
}

func MaskComposite(g *Graph, destination MASK, source MASK, x, y int, operation string) (_ *Node, mask MASK) {
	n := &Node{
		Class: "MaskComposite",
		Inputs: map[string]Value{
			"destination": Link(destination),
			"source":      Link(source),
			"x":           Int(x),
			"y":           Int(y),
			"operation":   String(operation),
		},
	}
	id := g.Add(n)
	return n, MASK{NodeID: id, OutPort: 0}
}

// MaskToImage - Convert Mask to Image
func MaskToImage(g *Graph, mask MASK) (_ *Node, image IMAGE) {
	n := &Node{
		Class: "MaskToImage",
		Inputs: map[string]Value{
			"mask": Link(mask),
		},
	}
	id := g.Add(n)
	return n, IMAGE{NodeID: id, OutPort: 0}
}

func ModelMergeAdd(g *Graph, model1 MODEL, model2 MODEL) (_ *Node, model MODEL) {
	n := &Node{
		Class: "ModelMergeAdd",
		Inputs: map[string]Value{
			"model1": Link(model1),
			"model2": Link(model2),
		},
	}
	id := g.Add(n)
	return n, MODEL{NodeID: id, OutPort: 0}
}

func ModelMergeBlocks(g *Graph, model1 MODEL, model2 MODEL, input, middle, out float64) (_ *Node, model MODEL) {
	n := &Node{
		Class: "ModelMergeBlocks",
		Inputs: map[string]Value{
			"model1": Link(model1),
			"model2": Link(model2),
			"input":  Float(input),
			"middle": Float(middle),
			"out":    Float(out),
		},
	}
	id := g.Add(n)
	return n, MODEL{NodeID: id, OutPort: 0}
}

func ModelMergeSD1(g *Graph, model1 MODEL, model2 MODEL, time_embed_, label_emb_, input_blocks_0_, input_blocks_1_, input_blocks_2_, input_blocks_3_, input_blocks_4_, input_blocks_5_, input_blocks_6_, input_blocks_7_, input_blocks_8_, input_blocks_9_, input_blocks_10_, input_blocks_11_, middle_block_0_, middle_block_1_, middle_block_2_, output_blocks_0_, output_blocks_1_, output_blocks_2_, output_blocks_3_, output_blocks_4_, output_blocks_5_, output_blocks_6_, output_blocks_7_, output_blocks_8_, output_blocks_9_, output_blocks_10_, output_blocks_11_, out_ float64) (_ *Node, model MODEL) {
	n := &Node{
		Class: "ModelMergeSD1",
		Inputs: map[string]Value{
			"model1":            Link(model1),
			"model2":            Link(model2),
			"time_embed.":       Float(time_embed_),
			"label_emb.":        Float(label_emb_),
			"input_blocks.0.":   Float(input_blocks_0_),
			"input_blocks.1.":   Float(input_blocks_1_),
			"input_blocks.2.":   Float(input_blocks_2_),
			"input_blocks.3.":   Float(input_blocks_3_),
			"input_blocks.4.":   Float(input_blocks_4_),
			"input_blocks.5.":   Float(input_blocks_5_),
			"input_blocks.6.":   Float(input_blocks_6_),
			"input_blocks.7.":   Float(input_blocks_7_),
			"input_blocks.8.":   Float(input_blocks_8_),
			"input_blocks.9.":   Float(input_blocks_9_),
			"input_blocks.10.":  Float(input_blocks_10_),
			"input_blocks.11.":  Float(input_blocks_11_),
			"middle_block.0.":   Float(middle_block_0_),
			"middle_block.1.":   Float(middle_block_1_),
			"middle_block.2.":   Float(middle_block_2_),
			"output_blocks.0.":  Float(output_blocks_0_),
			"output_blocks.1.":  Float(output_blocks_1_),
			"output_blocks.2.":  Float(output_blocks_2_),
			"output_blocks.3.":  Float(output_blocks_3_),
			"output_blocks.4.":  Float(output_blocks_4_),
			"output_blocks.5.":  Float(output_blocks_5_),
			"output_blocks.6.":  Float(output_blocks_6_),
			"output_blocks.7.":  Float(output_blocks_7_),
			"output_blocks.8.":  Float(output_blocks_8_),
			"output_blocks.9.":  Float(output_blocks_9_),
			"output_blocks.10.": Float(output_blocks_10_),
			"output_blocks.11.": Float(output_blocks_11_),
			"out.":              Float(out_),
		},
	}
	id := g.Add(n)
	return n, MODEL{NodeID: id, OutPort: 0}
}

func ModelMergeSD2(g *Graph, model1 MODEL, model2 MODEL, time_embed_, label_emb_, input_blocks_0_, input_blocks_1_, input_blocks_2_, input_blocks_3_, input_blocks_4_, input_blocks_5_, input_blocks_6_, input_blocks_7_, input_blocks_8_, input_blocks_9_, input_blocks_10_, input_blocks_11_, middle_block_0_, middle_block_1_, middle_block_2_, output_blocks_0_, output_blocks_1_, output_blocks_2_, output_blocks_3_, output_blocks_4_, output_blocks_5_, output_blocks_6_, output_blocks_7_, output_blocks_8_, output_blocks_9_, output_blocks_10_, output_blocks_11_, out_ float64) (_ *Node, model MODEL) {
	n := &Node{
		Class: "ModelMergeSD2",
		Inputs: map[string]Value{
			"model1":            Link(model1),
			"model2":            Link(model2),
			"time_embed.":       Float(time_embed_),
			"label_emb.":        Float(label_emb_),
			"input_blocks.0.":   Float(input_blocks_0_),
			"input_blocks.1.":   Float(input_blocks_1_),
			"input_blocks.2.":   Float(input_blocks_2_),
			"input_blocks.3.":   Float(input_blocks_3_),
			"input_blocks.4.":   Float(input_blocks_4_),
			"input_blocks.5.":   Float(input_blocks_5_),
			"input_blocks.6.":   Float(input_blocks_6_),
			"input_blocks.7.":   Float(input_blocks_7_),
			"input_blocks.8.":   Float(input_blocks_8_),
			"input_blocks.9.":   Float(input_blocks_9_),
			"input_blocks.10.":  Float(input_blocks_10_),
			"input_blocks.11.":  Float(input_blocks_11_),
			"middle_block.0.":   Float(middle_block_0_),
			"middle_block.1.":   Float(middle_block_1_),
			"middle_block.2.":   Float(middle_block_2_),
			"output_blocks.0.":  Float(output_blocks_0_),
			"output_blocks.1.":  Float(output_blocks_1_),
			"output_blocks.2.":  Float(output_blocks_2_),
			"output_blocks.3.":  Float(output_blocks_3_),
			"output_blocks.4.":  Float(output_blocks_4_),
			"output_blocks.5.":  Float(output_blocks_5_),
			"output_blocks.6.":  Float(output_blocks_6_),
			"output_blocks.7.":  Float(output_blocks_7_),
			"output_blocks.8.":  Float(output_blocks_8_),
			"output_blocks.9.":  Float(output_blocks_9_),
			"output_blocks.10.": Float(output_blocks_10_),
			"output_blocks.11.": Float(output_blocks_11_),
			"out.":              Float(out_),
		},
	}
	id := g.Add(n)
	return n, MODEL{NodeID: id, OutPort: 0}
}

func ModelMergeSD3(g *Graph, model1 MODEL, model2 MODEL, pos_embed_, x_embedder_, context_embedder_, y_embedder_, t_embedder_, joint_blocks_0_, joint_blocks_1_, joint_blocks_2_, joint_blocks_3_, joint_blocks_4_, joint_blocks_5_, joint_blocks_6_, joint_blocks_7_, joint_blocks_8_, joint_blocks_9_, joint_blocks_10_, joint_blocks_11_, joint_blocks_12_, joint_blocks_13_, joint_blocks_14_, joint_blocks_15_, joint_blocks_16_, joint_blocks_17_, joint_blocks_18_, joint_blocks_19_, joint_blocks_20_, joint_blocks_21_, joint_blocks_22_, joint_blocks_23_, joint_blocks_24_, joint_blocks_25_, joint_blocks_26_, joint_blocks_27_, joint_blocks_28_, joint_blocks_29_, joint_blocks_30_, joint_blocks_31_, joint_blocks_32_, joint_blocks_33_, joint_blocks_34_, joint_blocks_35_, joint_blocks_36_, joint_blocks_37_, final_layer_ float64) (_ *Node, model MODEL) {
	n := &Node{
		Class: "ModelMergeSD3",
		Inputs: map[string]Value{
			"model1":            Link(model1),
			"model2":            Link(model2),
			"pos_embed.":        Float(pos_embed_),
			"x_embedder.":       Float(x_embedder_),
			"context_embedder.": Float(context_embedder_),
			"y_embedder.":       Float(y_embedder_),
			"t_embedder.":       Float(t_embedder_),
			"joint_blocks.0.":   Float(joint_blocks_0_),
			"joint_blocks.1.":   Float(joint_blocks_1_),
			"joint_blocks.2.":   Float(joint_blocks_2_),
			"joint_blocks.3.":   Float(joint_blocks_3_),
			"joint_blocks.4.":   Float(joint_blocks_4_),
			"joint_blocks.5.":   Float(joint_blocks_5_),
			"joint_blocks.6.":   Float(joint_blocks_6_),
			"joint_blocks.7.":   Float(joint_blocks_7_),
			"joint_blocks.8.":   Float(joint_blocks_8_),
			"joint_blocks.9.":   Float(joint_blocks_9_),
			"joint_blocks.10.":  Float(joint_blocks_10_),
			"joint_blocks.11.":  Float(joint_blocks_11_),
			"joint_blocks.12.":  Float(joint_blocks_12_),
			"joint_blocks.13.":  Float(joint_blocks_13_),
			"joint_blocks.14.":  Float(joint_blocks_14_),
			"joint_blocks.15.":  Float(joint_blocks_15_),
			"joint_blocks.16.":  Float(joint_blocks_16_),
			"joint_blocks.17.":  Float(joint_blocks_17_),
			"joint_blocks.18.":  Float(joint_blocks_18_),
			"joint_blocks.19.":  Float(joint_blocks_19_),
			"joint_blocks.20.":  Float(joint_blocks_20_),
			"joint_blocks.21.":  Float(joint_blocks_21_),
			"joint_blocks.22.":  Float(joint_blocks_22_),
			"joint_blocks.23.":  Float(joint_blocks_23_),
			"joint_blocks.24.":  Float(joint_blocks_24_),
			"joint_blocks.25.":  Float(joint_blocks_25_),
			"joint_blocks.26.":  Float(joint_blocks_26_),
			"joint_blocks.27.":  Float(joint_blocks_27_),
			"joint_blocks.28.":  Float(joint_blocks_28_),
			"joint_blocks.29.":  Float(joint_blocks_29_),
			"joint_blocks.30.":  Float(joint_blocks_30_),
			"joint_blocks.31.":  Float(joint_blocks_31_),
			"joint_blocks.32.":  Float(joint_blocks_32_),
			"joint_blocks.33.":  Float(joint_blocks_33_),
			"joint_blocks.34.":  Float(joint_blocks_34_),
			"joint_blocks.35.":  Float(joint_blocks_35_),
			"joint_blocks.36.":  Float(joint_blocks_36_),
			"joint_blocks.37.":  Float(joint_blocks_37_),
			"final_layer.":      Float(final_layer_),
		},
	}
	id := g.Add(n)
	return n, MODEL{NodeID: id, OutPort: 0}
}

func ModelMergeSDXL(g *Graph, model1 MODEL, model2 MODEL, time_embed_, label_emb_, input_blocks_0, input_blocks_1, input_blocks_2, input_blocks_3, input_blocks_4, input_blocks_5, input_blocks_6, input_blocks_7, input_blocks_8, middle_block_0, middle_block_1, middle_block_2, output_blocks_0, output_blocks_1, output_blocks_2, output_blocks_3, output_blocks_4, output_blocks_5, output_blocks_6, output_blocks_7, output_blocks_8, out_ float64) (_ *Node, model MODEL) {
	n := &Node{
		Class: "ModelMergeSDXL",
		Inputs: map[string]Value{
			"model1":          Link(model1),
			"model2":          Link(model2),
			"time_embed.":     Float(time_embed_),
			"label_emb.":      Float(label_emb_),
			"input_blocks.0":  Float(input_blocks_0),
			"input_blocks.1":  Float(input_blocks_1),
			"input_blocks.2":  Float(input_blocks_2),
			"input_blocks.3":  Float(input_blocks_3),
			"input_blocks.4":  Float(input_blocks_4),
			"input_blocks.5":  Float(input_blocks_5),
			"input_blocks.6":  Float(input_blocks_6),
			"input_blocks.7":  Float(input_blocks_7),
			"input_blocks.8":  Float(input_blocks_8),
			"middle_block.0":  Float(middle_block_0),
			"middle_block.1":  Float(middle_block_1),
			"middle_block.2":  Float(middle_block_2),
			"output_blocks.0": Float(output_blocks_0),
			"output_blocks.1": Float(output_blocks_1),
			"output_blocks.2": Float(output_blocks_2),
			"output_blocks.3": Float(output_blocks_3),
			"output_blocks.4": Float(output_blocks_4),
			"output_blocks.5": Float(output_blocks_5),
			"output_blocks.6": Float(output_blocks_6),
			"output_blocks.7": Float(output_blocks_7),
			"output_blocks.8": Float(output_blocks_8),
			"out.":            Float(out_),
		},
	}
	id := g.Add(n)
	return n, MODEL{NodeID: id, OutPort: 0}
}

func ModelMergeSimple(g *Graph, model1 MODEL, model2 MODEL, ratio float64) (_ *Node, model MODEL) {
	n := &Node{
		Class: "ModelMergeSimple",
		Inputs: map[string]Value{
			"model1": Link(model1),
			"model2": Link(model2),
			"ratio":  Float(ratio),
		},
	}
	id := g.Add(n)
	return n, MODEL{NodeID: id, OutPort: 0}
}

func ModelMergeSubtract(g *Graph, model1 MODEL, model2 MODEL, multiplier float64) (_ *Node, model MODEL) {
	n := &Node{
		Class: "ModelMergeSubtract",
		Inputs: map[string]Value{
			"model1":     Link(model1),
			"model2":     Link(model2),
			"multiplier": Float(multiplier),
		},
	}
	id := g.Add(n)
	return n, MODEL{NodeID: id, OutPort: 0}
}

func ModelSamplingContinuousEDM(g *Graph, model MODEL, sampling string, sigma_max, sigma_min float64) (_ *Node, out_model MODEL) {
	n := &Node{
		Class: "ModelSamplingContinuousEDM",
		Inputs: map[string]Value{
			"model":     Link(model),
			"sampling":  String(sampling),
			"sigma_max": Float(sigma_max),
			"sigma_min": Float(sigma_min),
		},
	}
	id := g.Add(n)
	return n, MODEL{NodeID: id, OutPort: 0}
}

func ModelSamplingContinuousV(g *Graph, model MODEL, sampling string, sigma_max, sigma_min float64) (_ *Node, out_model MODEL) {
	n := &Node{
		Class: "ModelSamplingContinuousV",
		Inputs: map[string]Value{
			"model":     Link(model),
			"sampling":  String(sampling),
			"sigma_max": Float(sigma_max),
			"sigma_min": Float(sigma_min),
		},
	}
	id := g.Add(n)
	return n, MODEL{NodeID: id, OutPort: 0}
}

func ModelSamplingDiscrete(g *Graph, model MODEL, sampling string, zsnr bool) (_ *Node, out_model MODEL) {
	n := &Node{
		Class: "ModelSamplingDiscrete",
		Inputs: map[string]Value{
			"model":    Link(model),
			"sampling": String(sampling),
			"zsnr":     Bool(zsnr),
		},
	}
	id := g.Add(n)
	return n, MODEL{NodeID: id, OutPort: 0}
}

func ModelSamplingSD3(g *Graph, model MODEL, shift float64) (_ *Node, out_model MODEL) {
	n := &Node{
		Class: "ModelSamplingSD3",
		Inputs: map[string]Value{
			"model": Link(model),
			"shift": Float(shift),
		},
	}
	id := g.Add(n)
	return n, MODEL{NodeID: id, OutPort: 0}
}

func ModelSamplingStableCascade(g *Graph, model MODEL, shift float64) (_ *Node, out_model MODEL) {
	n := &Node{
		Class: "ModelSamplingStableCascade",
		Inputs: map[string]Value{
			"model": Link(model),
			"shift": Float(shift),
		},
	}
	id := g.Add(n)
	return n, MODEL{NodeID: id, OutPort: 0}
}

// Morphology - ImageMorphology
func Morphology(g *Graph, image IMAGE, operation string, kernel_size int) (_ *Node, out_image IMAGE) {
	n := &Node{
		Class: "Morphology",
		Inputs: map[string]Value{
			"image":       Link(image),
			"operation":   String(operation),
			"kernel_size": Int(kernel_size),
		},
	}
	id := g.Add(n)
	return n, IMAGE{NodeID: id, OutPort: 0}
}

// PatchModelAddDownscale - PatchModelAddDownscale (Kohya Deep Shrink)
func PatchModelAddDownscale(g *Graph, model MODEL, block_number int, downscale_factor, start_percent, end_percent float64, downscale_after_skip bool, downscale_method, upscale_method string) (_ *Node, out_model MODEL) {
	n := &Node{
		Class: "PatchModelAddDownscale",
		Inputs: map[string]Value{
			"model":                Link(model),
			"block_number":         Int(block_number),
			"downscale_factor":     Float(downscale_factor),
			"start_percent":        Float(start_percent),
			"end_percent":          Float(end_percent),
			"downscale_after_skip": Bool(downscale_after_skip),
			"downscale_method":     String(downscale_method),
			"upscale_method":       String(upscale_method),
		},
	}
	id := g.Add(n)
	return n, MODEL{NodeID: id, OutPort: 0}
}

// PerpNeg - Perp-Neg (DEPRECATED by PerpNegGuider)
func PerpNeg(g *Graph, model MODEL, empty_conditioning CONDITIONING, neg_scale float64) (_ *Node, out_model MODEL) {
	n := &Node{
		Class: "PerpNeg",
		Inputs: map[string]Value{
			"model":              Link(model),
			"empty_conditioning": Link(empty_conditioning),
			"neg_scale":          Float(neg_scale),
		},
	}
	id := g.Add(n)
	return n, MODEL{NodeID: id, OutPort: 0}
}

func PerpNegGuider(g *Graph, model MODEL, positive CONDITIONING, negative CONDITIONING, empty_conditioning CONDITIONING, cfg, neg_scale float64) (_ *Node, guider GUIDER) {
	n := &Node{
		Class: "PerpNegGuider",
		Inputs: map[string]Value{
			"model":              Link(model),
			"positive":           Link(positive),
			"negative":           Link(negative),
			"empty_conditioning": Link(empty_conditioning),
			"cfg":                Float(cfg),
			"neg_scale":          Float(neg_scale),
		},
	}
	id := g.Add(n)
	return n, GUIDER{NodeID: id, OutPort: 0}
}

func PerturbedAttentionGuidance(g *Graph, model MODEL, scale float64) (_ *Node, out_model MODEL) {
	n := &Node{
		Class: "PerturbedAttentionGuidance",
		Inputs: map[string]Value{
			"model": Link(model),
			"scale": Float(scale),
		},
	}
	id := g.Add(n)
	return n, MODEL{NodeID: id, OutPort: 0}
}

func PhotoMakerEncode(g *Graph, photomaker PHOTOMAKER, image IMAGE, clip CLIP, text string) (_ *Node, conditioning CONDITIONING) {
	n := &Node{
		Class: "PhotoMakerEncode",
		Inputs: map[string]Value{
			"photomaker": Link(photomaker),
			"image":      Link(image),
			"clip":       Link(clip),
			"text":       String(text),
		},
	}
	id := g.Add(n)
	return n, CONDITIONING{NodeID: id, OutPort: 0}
}

func PhotoMakerLoader(g *Graph, photomaker_model_name string) (_ *Node, photomaker PHOTOMAKER) {
	n := &Node{
		Class: "PhotoMakerLoader",
		Inputs: map[string]Value{
			"photomaker_model_name": String(photomaker_model_name),
		},
	}
	id := g.Add(n)
	return n, PHOTOMAKER{NodeID: id, OutPort: 0}
}

func PolyexponentialScheduler(g *Graph, steps int, sigma_max, sigma_min, rho float64) (_ *Node, sigmas SIGMAS) {
	n := &Node{
		Class: "PolyexponentialScheduler",
		Inputs: map[string]Value{
			"steps":     Int(steps),
			"sigma_max": Float(sigma_max),
			"sigma_min": Float(sigma_min),
			"rho":       Float(rho),
		},
	}
	id := g.Add(n)
	return n, SIGMAS{NodeID: id, OutPort: 0}
}

// PorterDuffImageComposite - Porter-Duff Image Composite
func PorterDuffImageComposite(g *Graph, source IMAGE, source_alpha MASK, destination IMAGE, destination_alpha MASK, mode string) (_ *Node, image IMAGE, mask MASK) {
	n := &Node{
		Class: "PorterDuffImageComposite",
		Inputs: map[string]Value{
			"source":            Link(source),
			"source_alpha":      Link(source_alpha),
			"destination":       Link(destination),
			"destination_alpha": Link(destination_alpha),
			"mode":              String(mode),
		},
	}
	id := g.Add(n)
	return n, IMAGE{NodeID: id, OutPort: 0}, MASK{NodeID: id, OutPort: 1}
}

// PreviewImage - Preview Image
func PreviewImage(g *Graph, images IMAGE) (_ *Node) {
	n := &Node{
		Class: "PreviewImage",
		Inputs: map[string]Value{
			"images": Link(images),
		},
	}
	g.Add(n)
	return n
}

func RandomNoise(g *Graph, noise_seed int) (_ *Node, noise NOISE) {
	n := &Node{
		Class: "RandomNoise",
		Inputs: map[string]Value{
			"noise_seed": Int(noise_seed),
		},
	}
	id := g.Add(n)
	return n, NOISE{NodeID: id, OutPort: 0}
}

// RebatchImages - Rebatch Images
func RebatchImages(g *Graph, images IMAGE, batch_size int) (_ *Node, image IMAGE) {
	n := &Node{
		Class: "RebatchImages",
		Inputs: map[string]Value{
			"images":     Link(images),
			"batch_size": Int(batch_size),
		},
	}
	id := g.Add(n)
	return n, IMAGE{NodeID: id, OutPort: 0}
}

// RebatchLatents - Rebatch Latents
func RebatchLatents(g *Graph, latents LATENT, batch_size int) (_ *Node, latent LATENT) {
	n := &Node{
		Class: "RebatchLatents",
		Inputs: map[string]Value{
			"latents":    Link(latents),
			"batch_size": Int(batch_size),
		},
	}
	id := g.Add(n)
	return n, LATENT{NodeID: id, OutPort: 0}
}

func RepeatImageBatch(g *Graph, image IMAGE, amount int) (_ *Node, out_image IMAGE) {
	n := &Node{
		Class: "RepeatImageBatch",
		Inputs: map[string]Value{
			"image":  Link(image),
			"amount": Int(amount),
		},
	}
	id := g.Add(n)
	return n, IMAGE{NodeID: id, OutPort: 0}
}

// RepeatLatentBatch - Repeat Latent Batch
func RepeatLatentBatch(g *Graph, samples LATENT, amount int) (_ *Node, latent LATENT) {
	n := &Node{
		Class: "RepeatLatentBatch",
		Inputs: map[string]Value{
			"samples": Link(samples),
			"amount":  Int(amount),
		},
	}
	id := g.Add(n)
	return n, LATENT{NodeID: id, OutPort: 0}
}

func RescaleCFG(g *Graph, model MODEL, multiplier float64) (_ *Node, out_model MODEL) {
	n := &Node{
		Class: "RescaleCFG",
		Inputs: map[string]Value{
			"model":      Link(model),
			"multiplier": Float(multiplier),
		},
	}
	id := g.Add(n)
	return n, MODEL{NodeID: id, OutPort: 0}
}

func SDTurboScheduler(g *Graph, model MODEL, steps int, denoise float64) (_ *Node, sigmas SIGMAS) {
	n := &Node{
		Class: "SDTurboScheduler",
		Inputs: map[string]Value{
			"model":   Link(model),
			"steps":   Int(steps),
			"denoise": Float(denoise),
		},
	}
	id := g.Add(n)
	return n, SIGMAS{NodeID: id, OutPort: 0}
}

func SD_4XUpscale_Conditioning(g *Graph, images IMAGE, positive CONDITIONING, negative CONDITIONING, scale_ratio, noise_augmentation float64) (_ *Node, out_positive CONDITIONING, out_negative CONDITIONING, latent LATENT) {
	n := &Node{
		Class: "SD_4XUpscale_Conditioning",
		Inputs: map[string]Value{
			"images":             Link(images),
			"positive":           Link(positive),
			"negative":           Link(negative),
			"scale_ratio":        Float(scale_ratio),
			"noise_augmentation": Float(noise_augmentation),
		},
	}
	id := g.Add(n)
	return n, CONDITIONING{NodeID: id, OutPort: 0}, CONDITIONING{NodeID: id, OutPort: 1}, LATENT{NodeID: id, OutPort: 2}
}

func SV3D_Conditioning(g *Graph, clip_vision CLIP_VISION, init_image IMAGE, vae VAE, width, height, video_frames int, elevation float64) (_ *Node, positive CONDITIONING, negative CONDITIONING, latent LATENT) {
	n := &Node{
		Class: "SV3D_Conditioning",
		Inputs: map[string]Value{
			"clip_vision":  Link(clip_vision),
			"init_image":   Link(init_image),
			"vae":          Link(vae),
			"width":        Int(width),
			"height":       Int(height),
			"video_frames": Int(video_frames),
			"elevation":    Float(elevation),
		},
	}
	id := g.Add(n)
	return n, CONDITIONING{NodeID: id, OutPort: 0}, CONDITIONING{NodeID: id, OutPort: 1}, LATENT{NodeID: id, OutPort: 2}
}

func SVD_img2vid_Conditioning(g *Graph, clip_vision CLIP_VISION, init_image IMAGE, vae VAE, width, height, video_frames, motion_bucket_id, fps int, augmentation_level float64) (_ *Node, positive CONDITIONING, negative CONDITIONING, latent LATENT) {
	n := &Node{
		Class: "SVD_img2vid_Conditioning",
		Inputs: map[string]Value{
			"clip_vision":        Link(clip_vision),
			"init_image":         Link(init_image),
			"vae":                Link(vae),
			"width":              Int(width),
			"height":             Int(height),
			"video_frames":       Int(video_frames),
			"motion_bucket_id":   Int(motion_bucket_id),
			"fps":                Int(fps),
			"augmentation_level": Float(augmentation_level),
		},
	}
	id := g.Add(n)
	return n, CONDITIONING{NodeID: id, OutPort: 0}, CONDITIONING{NodeID: id, OutPort: 1}, LATENT{NodeID: id, OutPort: 2}
}

func SamplerCustom(g *Graph, model MODEL, positive CONDITIONING, negative CONDITIONING, sampler SAMPLER, sigmas SIGMAS, latent_image LATENT, add_noise bool, noise_seed int, cfg float64) (_ *Node, output LATENT, denoised_output LATENT) {
	n := &Node{
		Class: "SamplerCustom",
		Inputs: map[string]Value{
			"model":        Link(model),
			"add_noise":    Bool(add_noise),
			"noise_seed":   Int(noise_seed),
			"cfg":          Float(cfg),
			"positive":     Link(positive),
			"negative":     Link(negative),
			"sampler":      Link(sampler),
			"sigmas":       Link(sigmas),
			"latent_image": Link(latent_image),
		},
	}
	id := g.Add(n)
	return n, LATENT{NodeID: id, OutPort: 0}, LATENT{NodeID: id, OutPort: 1}
}

func SamplerCustomAdvanced(g *Graph, noise NOISE, guider GUIDER, sampler SAMPLER, sigmas SIGMAS, latent_image LATENT) (_ *Node, output LATENT, denoised_output LATENT) {
	n := &Node{
		Class: "SamplerCustomAdvanced",
		Inputs: map[string]Value{
			"noise":        Link(noise),
			"guider":       Link(guider),
			"sampler":      Link(sampler),
			"sigmas":       Link(sigmas),
			"latent_image": Link(latent_image),
		},
	}
	id := g.Add(n)
	return n, LATENT{NodeID: id, OutPort: 0}, LATENT{NodeID: id, OutPort: 1}
}

func SamplerDPMAdaptative(g *Graph, order int, rtol, atol, h_init, pcoeff, icoeff, dcoeff, accept_safety, eta, s_noise float64) (_ *Node, sampler SAMPLER) {
	n := &Node{
		Class: "SamplerDPMAdaptative",
		Inputs: map[string]Value{
			"order":         Int(order),
			"rtol":          Float(rtol),
			"atol":          Float(atol),
			"h_init":        Float(h_init),
			"pcoeff":        Float(pcoeff),
			"icoeff":        Float(icoeff),
			"dcoeff":        Float(dcoeff),
			"accept_safety": Float(accept_safety),
			"eta":           Float(eta),
			"s_noise":       Float(s_noise),
		},
	}
	id := g.Add(n)
	return n, SAMPLER{NodeID: id, OutPort: 0}
}

func SamplerDPMPP_2M_SDE(g *Graph, solver_type string, eta, s_noise float64, noise_device string) (_ *Node, sampler SAMPLER) {
	n := &Node{
		Class: "SamplerDPMPP_2M_SDE",
		Inputs: map[string]Value{
			"solver_type":  String(solver_type),
			"eta":          Float(eta),
			"s_noise":      Float(s_noise),
			"noise_device": String(noise_device),
		},
	}
	id := g.Add(n)
	return n, SAMPLER{NodeID: id, OutPort: 0}
}

func SamplerDPMPP_3M_SDE(g *Graph, eta, s_noise float64, noise_device string) (_ *Node, sampler SAMPLER) {
	n := &Node{
		Class: "SamplerDPMPP_3M_SDE",
		Inputs: map[string]Value{
			"eta":          Float(eta),
			"s_noise":      Float(s_noise),
			"noise_device": String(noise_device),
		},
	}
	id := g.Add(n)
	return n, SAMPLER{NodeID: id, OutPort: 0}
}

func SamplerDPMPP_SDE(g *Graph, eta, s_noise, r float64, noise_device string) (_ *Node, sampler SAMPLER) {
	n := &Node{
		Class: "SamplerDPMPP_SDE",
		Inputs: map[string]Value{
			"eta":          Float(eta),
			"s_noise":      Float(s_noise),
			"r":            Float(r),
			"noise_device": String(noise_device),
		},
	}
	id := g.Add(n)
	return n, SAMPLER{NodeID: id, OutPort: 0}
}

func SamplerEulerAncestral(g *Graph, eta, s_noise float64) (_ *Node, sampler SAMPLER) {
	n := &Node{
		Class: "SamplerEulerAncestral",
		Inputs: map[string]Value{
			"eta":     Float(eta),
			"s_noise": Float(s_noise),
		},
	}
	id := g.Add(n)
	return n, SAMPLER{NodeID: id, OutPort: 0}
}

func SamplerLCMUpscale(g *Graph, scale_ratio float64, scale_steps int, upscale_method string) (_ *Node, sampler SAMPLER) {
	n := &Node{
		Class: "SamplerLCMUpscale",
		Inputs: map[string]Value{
			"scale_ratio":    Float(scale_ratio),
			"scale_steps":    Int(scale_steps),
			"upscale_method": String(upscale_method),
		},
	}
	id := g.Add(n)
	return n, SAMPLER{NodeID: id, OutPort: 0}
}

func SamplerLMS(g *Graph, order int) (_ *Node, sampler SAMPLER) {
	n := &Node{
		Class: "SamplerLMS",
		Inputs: map[string]Value{
			"order": Int(order),
		},
	}
	id := g.Add(n)
	return n, SAMPLER{NodeID: id, OutPort: 0}
}

func SaveAnimatedPNG(g *Graph, images IMAGE, filename_prefix string, fps float64, compress_level int) (_ *Node) {
	n := &Node{
		Class: "SaveAnimatedPNG",
		Inputs: map[string]Value{
			"images":          Link(images),
			"filename_prefix": String(filename_prefix),
			"fps":             Float(fps),
			"compress_level":  Int(compress_level),
		},
	}
	g.Add(n)
	return n
}

func SaveAnimatedWEBP(g *Graph, images IMAGE, filename_prefix string, fps float64, lossless bool, quality int, method string) (_ *Node) {
	n := &Node{
		Class: "SaveAnimatedWEBP",
		Inputs: map[string]Value{
			"images":          Link(images),
			"filename_prefix": String(filename_prefix),
			"fps":             Float(fps),
			"lossless":        Bool(lossless),
			"quality":         Int(quality),
			"method":          String(method),
		},
	}
	g.Add(n)
	return n
}

func SaveAudio(g *Graph, audio AUDIO, filename_prefix string) (_ *Node) {
	n := &Node{
		Class: "SaveAudio",
		Inputs: map[string]Value{
			"audio":           Link(audio),
			"filename_prefix": String(filename_prefix),
		},
	}
	g.Add(n)
	return n
}

// SaveImage - Save Image
func SaveImage(g *Graph, images IMAGE, filename_prefix string) (_ *Node) {
	n := &Node{
		Class: "SaveImage",
		Inputs: map[string]Value{
			"images":          Link(images),
			"filename_prefix": String(filename_prefix),
		},
	}
	g.Add(n)
	return n
}

func SaveImageWebsocket(g *Graph, images IMAGE) (_ *Node) {
	n := &Node{
		Class: "SaveImageWebsocket",
		Inputs: map[string]Value{
			"images": Link(images),
		},
	}
	g.Add(n)
	return n
}

func SaveLatent(g *Graph, samples LATENT, filename_prefix string) (_ *Node) {
	n := &Node{
		Class: "SaveLatent",
		Inputs: map[string]Value{
			"samples":         Link(samples),
			"filename_prefix": String(filename_prefix),
		},
	}
	g.Add(n)
	return n
}

// SelfAttentionGuidance - Self-Attention Guidance
func SelfAttentionGuidance(g *Graph, model MODEL, scale, blur_sigma float64) (_ *Node, out_model MODEL) {
	n := &Node{
		Class: "SelfAttentionGuidance",
		Inputs: map[string]Value{
			"model":      Link(model),
			"scale":      Float(scale),
			"blur_sigma": Float(blur_sigma),
		},
	}
	id := g.Add(n)
	return n, MODEL{NodeID: id, OutPort: 0}
}

// SetLatentNoiseMask - Set Latent Noise Mask
func SetLatentNoiseMask(g *Graph, samples LATENT, mask MASK) (_ *Node, latent LATENT) {
	n := &Node{
		Class: "SetLatentNoiseMask",
		Inputs: map[string]Value{
			"samples": Link(samples),
			"mask":    Link(mask),
		},
	}
	id := g.Add(n)
	return n, LATENT{NodeID: id, OutPort: 0}
}

func SolidMask(g *Graph, value float64, width, height int) (_ *Node, mask MASK) {
	n := &Node{
		Class: "SolidMask",
		Inputs: map[string]Value{
			"value":  Float(value),
			"width":  Int(width),
			"height": Int(height),
		},
	}
	id := g.Add(n)
	return n, MASK{NodeID: id, OutPort: 0}
}

// SplitImageWithAlpha - Split Image with Alpha
func SplitImageWithAlpha(g *Graph, image IMAGE) (_ *Node, out_image IMAGE, mask MASK) {
	n := &Node{
		Class: "SplitImageWithAlpha",
		Inputs: map[string]Value{
			"image": Link(image),
		},
	}
	id := g.Add(n)
	return n, IMAGE{NodeID: id, OutPort: 0}, MASK{NodeID: id, OutPort: 1}
}

func SplitSigmas(g *Graph, sigmas SIGMAS, step int) (_ *Node, high_sigmas SIGMAS, low_sigmas SIGMAS) {
	n := &Node{
		Class: "SplitSigmas",
		Inputs: map[string]Value{
			"sigmas": Link(sigmas),
			"step":   Int(step),
		},
	}
	id := g.Add(n)
	return n, SIGMAS{NodeID: id, OutPort: 0}, SIGMAS{NodeID: id, OutPort: 1}
}

func SplitSigmasDenoise(g *Graph, sigmas SIGMAS, denoise float64) (_ *Node, high_sigmas SIGMAS, low_sigmas SIGMAS) {
	n := &Node{
		Class: "SplitSigmasDenoise",
		Inputs: map[string]Value{
			"sigmas":  Link(sigmas),
			"denoise": Float(denoise),
		},
	}
	id := g.Add(n)
	return n, SIGMAS{NodeID: id, OutPort: 0}, SIGMAS{NodeID: id, OutPort: 1}
}

func StableCascade_EmptyLatentImage(g *Graph, width, height, compression, batch_size int) (_ *Node, stage_c LATENT, stage_b LATENT) {
	n := &Node{
		Class: "StableCascade_EmptyLatentImage",
		Inputs: map[string]Value{
			"width":       Int(width),
			"height":      Int(height),
			"compression": Int(compression),
			"batch_size":  Int(batch_size),
		},
	}
	id := g.Add(n)
	return n, LATENT{NodeID: id, OutPort: 0}, LATENT{NodeID: id, OutPort: 1}
}

func StableCascade_StageB_Conditioning(g *Graph, conditioning CONDITIONING, stage_c LATENT) (_ *Node, out_conditioning CONDITIONING) {
	n := &Node{
		Class: "StableCascade_StageB_Conditioning",
		Inputs: map[string]Value{
			"conditioning": Link(conditioning),
			"stage_c":      Link(stage_c),
		},
	}
	id := g.Add(n)
	return n, CONDITIONING{NodeID: id, OutPort: 0}
}

func StableCascade_StageC_VAEEncode(g *Graph, image IMAGE, vae VAE, compression int) (_ *Node, stage_c LATENT, stage_b LATENT) {
	n := &Node{
		Class: "StableCascade_StageC_VAEEncode",
		Inputs: map[string]Value{
			"image":       Link(image),
			"vae":         Link(vae),
			"compression": Int(compression),
		},
	}
	id := g.Add(n)
	return n, LATENT{NodeID: id, OutPort: 0}, LATENT{NodeID: id, OutPort: 1}
}

func StableCascade_SuperResolutionControlnet(g *Graph, image IMAGE, vae VAE) (_ *Node, controlnet_input IMAGE, stage_c LATENT, stage_b LATENT) {
	n := &Node{
		Class: "StableCascade_SuperResolutionControlnet",
		Inputs: map[string]Value{
			"image": Link(image),
			"vae":   Link(vae),
		},
	}
	id := g.Add(n)
	return n, IMAGE{NodeID: id, OutPort: 0}, LATENT{NodeID: id, OutPort: 1}, LATENT{NodeID: id, OutPort: 2}
}

func StableZero123_Conditioning(g *Graph, clip_vision CLIP_VISION, init_image IMAGE, vae VAE, width, height, batch_size int, elevation, azimuth float64) (_ *Node, positive CONDITIONING, negative CONDITIONING, latent LATENT) {
	n := &Node{
		Class: "StableZero123_Conditioning",
		Inputs: map[string]Value{
			"clip_vision": Link(clip_vision),
			"init_image":  Link(init_image),
			"vae":         Link(vae),
			"width":       Int(width),
			"height":      Int(height),
			"batch_size":  Int(batch_size),
			"elevation":   Float(elevation),
			"azimuth":     Float(azimuth),
		},
	}
	id := g.Add(n)
	return n, CONDITIONING{NodeID: id, OutPort: 0}, CONDITIONING{NodeID: id, OutPort: 1}, LATENT{NodeID: id, OutPort: 2}
}

func StableZero123_Conditioning_Batched(g *Graph, clip_vision CLIP_VISION, init_image IMAGE, vae VAE, width, height, batch_size int, elevation, azimuth, elevation_batch_increment, azimuth_batch_increment float64) (_ *Node, positive CONDITIONING, negative CONDITIONING, latent LATENT) {
	n := &Node{
		Class: "StableZero123_Conditioning_Batched",
		Inputs: map[string]Value{
			"clip_vision":               Link(clip_vision),
			"init_image":                Link(init_image),
			"vae":                       Link(vae),
			"width":                     Int(width),
			"height":                    Int(height),
			"batch_size":                Int(batch_size),
			"elevation":                 Float(elevation),
			"azimuth":                   Float(azimuth),
			"elevation_batch_increment": Float(elevation_batch_increment),
			"azimuth_batch_increment":   Float(azimuth_batch_increment),
		},
	}
	id := g.Add(n)
	return n, CONDITIONING{NodeID: id, OutPort: 0}, CONDITIONING{NodeID: id, OutPort: 1}, LATENT{NodeID: id, OutPort: 2}
}

// StyleModelApply - Apply Style Model
func StyleModelApply(g *Graph, conditioning CONDITIONING, style_model STYLE_MODEL, clip_vision_output CLIP_VISION_OUTPUT) (_ *Node, out_conditioning CONDITIONING) {
	n := &Node{
		Class: "StyleModelApply",
		Inputs: map[string]Value{
			"conditioning":       Link(conditioning),
			"style_model":        Link(style_model),
			"clip_vision_output": Link(clip_vision_output),
		},
	}
	id := g.Add(n)
	return n, CONDITIONING{NodeID: id, OutPort: 0}
}

// StyleModelLoader - Load Style Model
func StyleModelLoader(g *Graph, style_model_name string) (_ *Node, style_model STYLE_MODEL) {
	n := &Node{
		Class: "StyleModelLoader",
		Inputs: map[string]Value{
			"style_model_name": String(style_model_name),
		},
	}
	id := g.Add(n)
	return n, STYLE_MODEL{NodeID: id, OutPort: 0}
}

func ThresholdMask(g *Graph, mask MASK, value float64) (_ *Node, out_mask MASK) {
	n := &Node{
		Class: "ThresholdMask",
		Inputs: map[string]Value{
			"mask":  Link(mask),
			"value": Float(value),
		},
	}
	id := g.Add(n)
	return n, MASK{NodeID: id, OutPort: 0}
}

func TomePatchModel(g *Graph, model MODEL, ratio float64) (_ *Node, out_model MODEL) {
	n := &Node{
		Class: "TomePatchModel",
		Inputs: map[string]Value{
			"model": Link(model),
			"ratio": Float(ratio),
		},
	}
	id := g.Add(n)
	return n, MODEL{NodeID: id, OutPort: 0}
}

func TripleCLIPLoader(g *Graph, clip_name1, clip_name2, clip_name3 string) (_ *Node, clip CLIP) {
	n := &Node{
		Class: "TripleCLIPLoader",
		Inputs: map[string]Value{
			"clip_name1": String(clip_name1),
			"clip_name2": String(clip_name2),
			"clip_name3": String(clip_name3),
		},
	}
	id := g.Add(n)
	return n, CLIP{NodeID: id, OutPort: 0}
}

func UNETLoader(g *Graph, unet_name string) (_ *Node, model MODEL) {
	n := &Node{
		Class: "UNETLoader",
		Inputs: map[string]Value{
			"unet_name": String(unet_name),
		},
	}
	id := g.Add(n)
	return n, MODEL{NodeID: id, OutPort: 0}
}

func UNetCrossAttentionMultiply(g *Graph, model MODEL, q, k, v, out float64) (_ *Node, out_model MODEL) {
	n := &Node{
		Class: "UNetCrossAttentionMultiply",
		Inputs: map[string]Value{
			"model": Link(model),
			"q":     Float(q),
			"k":     Float(k),
			"v":     Float(v),
			"out":   Float(out),
		},
	}
	id := g.Add(n)
	return n, MODEL{NodeID: id, OutPort: 0}
}

func UNetSelfAttentionMultiply(g *Graph, model MODEL, q, k, v, out float64) (_ *Node, out_model MODEL) {
	n := &Node{
		Class: "UNetSelfAttentionMultiply",
		Inputs: map[string]Value{
			"model": Link(model),
			"q":     Float(q),
			"k":     Float(k),
			"v":     Float(v),
			"out":   Float(out),
		},
	}
	id := g.Add(n)
	return n, MODEL{NodeID: id, OutPort: 0}
}

func UNetTemporalAttentionMultiply(g *Graph, model MODEL, self_structural, self_temporal, cross_structural, cross_temporal float64) (_ *Node, out_model MODEL) {
	n := &Node{
		Class: "UNetTemporalAttentionMultiply",
		Inputs: map[string]Value{
			"model":            Link(model),
			"self_structural":  Float(self_structural),
			"self_temporal":    Float(self_temporal),
			"cross_structural": Float(cross_structural),
			"cross_temporal":   Float(cross_temporal),
		},
	}
	id := g.Add(n)
	return n, MODEL{NodeID: id, OutPort: 0}
}

// UpscaleModelLoader - Load Upscale Model
func UpscaleModelLoader(g *Graph, model_name string) (_ *Node, upscale_model UPSCALE_MODEL) {
	n := &Node{
		Class: "UpscaleModelLoader",
		Inputs: map[string]Value{
			"model_name": String(model_name),
		},
	}
	id := g.Add(n)
	return n, UPSCALE_MODEL{NodeID: id, OutPort: 0}
}

// VAEDecode - VAE Decode
func VAEDecode(g *Graph, samples LATENT, vae VAE) (_ *Node, image IMAGE) {
	n := &Node{
		Class: "VAEDecode",
		Inputs: map[string]Value{
			"samples": Link(samples),
			"vae":     Link(vae),
		},
	}
	id := g.Add(n)
	return n, IMAGE{NodeID: id, OutPort: 0}
}

func VAEDecodeAudio(g *Graph, samples LATENT, vae VAE) (_ *Node, audio AUDIO) {
	n := &Node{
		Class: "VAEDecodeAudio",
		Inputs: map[string]Value{
			"samples": Link(samples),
			"vae":     Link(vae),
		},
	}
	id := g.Add(n)
	return n, AUDIO{NodeID: id, OutPort: 0}
}

// VAEDecodeTiled - VAE Decode (Tiled)
func VAEDecodeTiled(g *Graph, samples LATENT, vae VAE, tile_size int) (_ *Node, image IMAGE) {
	n := &Node{
		Class: "VAEDecodeTiled",
		Inputs: map[string]Value{
			"samples":   Link(samples),
			"vae":       Link(vae),
			"tile_size": Int(tile_size),
		},
	}
	id := g.Add(n)
	return n, IMAGE{NodeID: id, OutPort: 0}
}

// VAEEncode - VAE Encode
func VAEEncode(g *Graph, pixels IMAGE, vae VAE) (_ *Node, latent LATENT) {
	n := &Node{
		Class: "VAEEncode",
		Inputs: map[string]Value{
			"pixels": Link(pixels),
			"vae":    Link(vae),
		},
	}
	id := g.Add(n)
	return n, LATENT{NodeID: id, OutPort: 0}
}

func VAEEncodeAudio(g *Graph, audio AUDIO, vae VAE) (_ *Node, latent LATENT) {
	n := &Node{
		Class: "VAEEncodeAudio",
		Inputs: map[string]Value{
			"audio": Link(audio),
			"vae":   Link(vae),
		},
	}
	id := g.Add(n)
	return n, LATENT{NodeID: id, OutPort: 0}
}

// VAEEncodeForInpaint - VAE Encode (for Inpainting)
func VAEEncodeForInpaint(g *Graph, pixels IMAGE, vae VAE, mask MASK, grow_mask_by int) (_ *Node, latent LATENT) {
	n := &Node{
		Class: "VAEEncodeForInpaint",
		Inputs: map[string]Value{
			"pixels":       Link(pixels),
			"vae":          Link(vae),
			"mask":         Link(mask),
			"grow_mask_by": Int(grow_mask_by),
		},
	}
	id := g.Add(n)
	return n, LATENT{NodeID: id, OutPort: 0}
}

// VAEEncodeTiled - VAE Encode (Tiled)
func VAEEncodeTiled(g *Graph, pixels IMAGE, vae VAE, tile_size int) (_ *Node, latent LATENT) {
	n := &Node{
		Class: "VAEEncodeTiled",
		Inputs: map[string]Value{
			"pixels":    Link(pixels),
			"vae":       Link(vae),
			"tile_size": Int(tile_size),
		},
	}
	id := g.Add(n)
	return n, LATENT{NodeID: id, OutPort: 0}
}

// VAELoader - Load VAE
func VAELoader(g *Graph, vae_name string) (_ *Node, vae VAE) {
	n := &Node{
		Class: "VAELoader",
		Inputs: map[string]Value{
			"vae_name": String(vae_name),
		},
	}
	id := g.Add(n)
	return n, VAE{NodeID: id, OutPort: 0}
}

func VAESave(g *Graph, vae VAE, filename_prefix string) (_ *Node) {
	n := &Node{
		Class: "VAESave",
		Inputs: map[string]Value{
			"vae":             Link(vae),
			"filename_prefix": String(filename_prefix),
		},
	}
	g.Add(n)
	return n
}

func VPScheduler(g *Graph, steps int, beta_d, beta_min, eps_s float64) (_ *Node, sigmas SIGMAS) {
	n := &Node{
		Class: "VPScheduler",
		Inputs: map[string]Value{
			"steps":    Int(steps),
			"beta_d":   Float(beta_d),
			"beta_min": Float(beta_min),
			"eps_s":    Float(eps_s),
		},
	}
	id := g.Add(n)
	return n, SIGMAS{NodeID: id, OutPort: 0}
}

func VideoLinearCFGGuidance(g *Graph, model MODEL, min_cfg float64) (_ *Node, out_model MODEL) {
	n := &Node{
		Class: "VideoLinearCFGGuidance",
		Inputs: map[string]Value{
			"model":   Link(model),
			"min_cfg": Float(min_cfg),
		},
	}
	id := g.Add(n)
	return n, MODEL{NodeID: id, OutPort: 0}
}

func VideoTriangleCFGGuidance(g *Graph, model MODEL, min_cfg float64) (_ *Node, out_model MODEL) {
	n := &Node{
		Class: "VideoTriangleCFGGuidance",
		Inputs: map[string]Value{
			"model":   Link(model),
			"min_cfg": Float(min_cfg),
		},
	}
	id := g.Add(n)
	return n, MODEL{NodeID: id, OutPort: 0}
}

// WebcamCapture - Webcam Capture
func WebcamCapture(g *Graph, image WEBCAM, width, height int, capture_on_queue bool) (_ *Node, out_image IMAGE) {
	n := &Node{
		Class: "WebcamCapture",
		Inputs: map[string]Value{
			"image":            Link(image),
			"width":            Int(width),
			"height":           Int(height),
			"capture_on_queue": Bool(capture_on_queue),
		},
	}
	id := g.Add(n)
	return n, IMAGE{NodeID: id, OutPort: 0}
}

// UnCLIPCheckpointLoader - unCLIPCheckpointLoader
func UnCLIPCheckpointLoader(g *Graph, ckpt_name string) (_ *Node, model MODEL, clip CLIP, vae VAE, clip_vision CLIP_VISION) {
	n := &Node{
		Class: "unCLIPCheckpointLoader",
		Inputs: map[string]Value{
			"ckpt_name": String(ckpt_name),
		},
	}
	id := g.Add(n)
	return n, MODEL{NodeID: id, OutPort: 0}, CLIP{NodeID: id, OutPort: 1}, VAE{NodeID: id, OutPort: 2}, CLIP_VISION{NodeID: id, OutPort: 3}
}

// UnCLIPConditioning - unCLIPConditioning
func UnCLIPConditioning(g *Graph, conditioning CONDITIONING, clip_vision_output CLIP_VISION_OUTPUT, strength, noise_augmentation float64) (_ *Node, out_conditioning CONDITIONING) {
	n := &Node{
		Class: "unCLIPConditioning",
		Inputs: map[string]Value{
			"conditioning":       Link(conditioning),
			"clip_vision_output": Link(clip_vision_output),
			"strength":           Float(strength),
			"noise_augmentation": Float(noise_augmentation),
		},
	}
	id := g.Add(n)
	return n, CONDITIONING{NodeID: id, OutPort: 0}
}
